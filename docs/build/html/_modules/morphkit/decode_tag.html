

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>morphkit.decode_tag &mdash; Morphkit Documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=8d563738"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            morphkit
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Content</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Usage</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Functions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../genindex.html">Index</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/autogen/morphkit.analyze_pos.html">morphkit.analyze_pos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/autogen/morphkit.analyze_morph_tag.html">morphkit.analyze_morph_tag</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/autogen/morphkit.analyze_word_with_morpheus.html">morphkit.analyze_word_with_morpheus</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/autogen/morphkit.annotate_and_sort_analyses.html">morphkit.annotate_and_sort_analyses</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/autogen/morphkit.compare_tags.html">morphkit.compare_tags</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/autogen/morphkit.decode_tag.html">morphkit.decode_tag</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/autogen/morphkit.get_word_blocks.html">morphkit.get_word_blocks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/autogen/morphkit.init_compare_tags.html">morphkit.init_compare_tags</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/autogen/morphkit.parse_word_block.html">morphkit.parse_word_block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/autogen/morphkit.split_into_raw_blocks.html">morphkit.split_into_raw_blocks</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">morphkit</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">morphkit.decode_tag</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for morphkit.decode_tag</h1><div class="highlight"><pre>
<span></span><span class="c1"># morphkit/decode_tag.py</span>
<span class="c1"># SPDX-License-Identifier: CC-BY-4.0</span>
<span class="c1"># Copyright (c) 2025 Tony Jurg</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;0.0.1&quot;</span>

<span class="c1"># import required packages</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span>

<div class="viewcode-block" id="decode_tag">
<a class="viewcode-back" href="../../api/morphkit.decode_tag.html#morphkit.decode_tag">[docs]</a>
<span class="k">def</span> <span class="nf">decode_tag</span><span class="p">(</span><span class="n">tag_input</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">debug</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decode a morphological tag into a set of human-readable features.</span>

<span class="sd">    This function takes a morphological tag (e.g. &quot;V-PAI-3S&quot;) and returns</span>
<span class="sd">    a dictionary of interpreted grammatical properties, such as `Part of Speech`,</span>
<span class="sd">    `case`, `number`, `gender`, `tense`, `voice`, `mood`, `person`, and any `suffix` details.</span>

<span class="sd">    Args:</span>
<span class="sd">    -----</span>
<span class="sd">    </span>
<span class="sd">        :tag_input (str): The raw morphological tag string. Usually includes prefixes</span>
<span class="sd">            like &quot;N-&quot;, &quot;V-&quot;, &quot;A-&quot;, etc., followed by coded letters/numbers.</span>

<span class="sd">        :debug (bool): Optional argument. Defaults to `False`. If set to `True` the function print some debug information.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">        :Dict[str, Any]: A mapping from feature names to their full descriptions.</span>

<span class="sd">            Possible keys include:</span>
<span class="sd">              - &quot;Part of Speech&quot;</span>
<span class="sd">              - &quot;Case&quot;, &quot;Number&quot;, &quot;Gender&quot;</span>
<span class="sd">              - &quot;Tense&quot;, &quot;Voice&quot;, &quot;Mood&quot;</span>
<span class="sd">              - &quot;Verb Extra&quot; or &quot;Suffix&quot;</span>
<span class="sd">              - &quot;Warning&quot;, warning related to feature elements</span>
<span class="sd">              - &quot;Error&quot; (e.g., if input is empty)</span>

<span class="sd">        If the part of speech can not be determined, it returns `{&quot;Part of Speech&quot;: &quot;Unknown or Unsupported&quot;}`.</span>

<span class="sd">        If `tag_input` is empty or whitespace, it returns `{&quot;Error&quot;: &quot;Please enter a parsing tag.&quot;}`.</span>

<span class="sd">    Example:</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    .. code-block:: python</span>
<span class="sd">    </span>
<span class="sd">        morphkit.decode_tag(&quot;N-NSM&quot;)</span>
<span class="sd">        {</span>
<span class="sd">            &quot;Part of Speech&quot;: &quot;Noun&quot;,</span>
<span class="sd">            &quot;Case&quot;: &quot;Nominative&quot;,</span>
<span class="sd">            &quot;Number&quot;: &quot;Singular&quot;,</span>
<span class="sd">            &quot;Gender&quot;: &quot;Masculine&quot;,</span>
<span class="sd">            ...</span>
<span class="sd">        }</span>

<span class="sd">    Note:</span>
<span class="sd">    -----</span>

<span class="sd">        This function is an addapted version of the tool available at https://github.com/tonyjurg/Sandborg-Petersen-decoder.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Main Part of Speech mapping</span>
    <span class="n">posMap</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;N-PRI&quot;</span><span class="p">:</span> <span class="s2">&quot;Proper Noun Indeclinable&quot;</span><span class="p">,</span>  <span class="c1"># first the subset since decoding is based on &#39;first match&#39;</span>
        <span class="s2">&quot;N-LI&quot;</span><span class="p">:</span>  <span class="s2">&quot;Letter Indeclinable&quot;</span><span class="p">,</span>
        <span class="s2">&quot;N-OI&quot;</span><span class="p">:</span>  <span class="s2">&quot;Noun Other Type Indeclinable&quot;</span><span class="p">,</span>
        <span class="s2">&quot;N-&quot;</span><span class="p">:</span>    <span class="s2">&quot;Noun&quot;</span><span class="p">,</span>  <span class="c1"># generic Noun</span>
        <span class="s2">&quot;A-NUI&quot;</span><span class="p">:</span> <span class="s2">&quot;Numeral Indeclinable&quot;</span><span class="p">,</span> 
        <span class="s2">&quot;A-&quot;</span><span class="p">:</span>    <span class="s2">&quot;Adjective&quot;</span><span class="p">,</span>
        <span class="s2">&quot;T-&quot;</span><span class="p">:</span>    <span class="s2">&quot;Article&quot;</span><span class="p">,</span>
        <span class="s2">&quot;V-&quot;</span><span class="p">:</span>    <span class="s2">&quot;Verb&quot;</span><span class="p">,</span>
        <span class="s2">&quot;P-&quot;</span><span class="p">:</span>    <span class="s2">&quot;Personal Pronoun&quot;</span><span class="p">,</span>
        <span class="s2">&quot;R-&quot;</span><span class="p">:</span>    <span class="s2">&quot;Relative Pronoun&quot;</span><span class="p">,</span>
        <span class="s2">&quot;C-&quot;</span><span class="p">:</span>    <span class="s2">&quot;Reciprocal Pronoun&quot;</span><span class="p">,</span>
        <span class="s2">&quot;D-&quot;</span><span class="p">:</span>    <span class="s2">&quot;Demonstrative Pronoun&quot;</span><span class="p">,</span>
        <span class="s2">&quot;K-&quot;</span><span class="p">:</span>    <span class="s2">&quot;Correlative Pronoun&quot;</span><span class="p">,</span>
        <span class="s2">&quot;I-&quot;</span><span class="p">:</span>    <span class="s2">&quot;Interrogative Pronoun&quot;</span><span class="p">,</span>
        <span class="s2">&quot;X-&quot;</span><span class="p">:</span>    <span class="s2">&quot;Indefinite Pronoun&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Q-&quot;</span><span class="p">:</span>    <span class="s2">&quot;Correlative/Interrogative Pronoun&quot;</span><span class="p">,</span>
        <span class="s2">&quot;F-&quot;</span><span class="p">:</span>    <span class="s2">&quot;Reflexive Pronoun&quot;</span><span class="p">,</span>
        <span class="s2">&quot;S-&quot;</span><span class="p">:</span>    <span class="s2">&quot;Possessive Pronoun&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ADV&quot;</span><span class="p">:</span>   <span class="s2">&quot;Adverb&quot;</span><span class="p">,</span>
        <span class="s2">&quot;CONJ&quot;</span><span class="p">:</span>  <span class="s2">&quot;Conjunction&quot;</span><span class="p">,</span>
        <span class="s2">&quot;COND&quot;</span><span class="p">:</span>  <span class="s2">&quot;Conditional&quot;</span><span class="p">,</span>
        <span class="s2">&quot;PRT&quot;</span><span class="p">:</span>   <span class="s2">&quot;Particle&quot;</span><span class="p">,</span>
        <span class="s2">&quot;PREP&quot;</span><span class="p">:</span>  <span class="s2">&quot;Preposition&quot;</span><span class="p">,</span>
        <span class="s2">&quot;INJ&quot;</span><span class="p">:</span>   <span class="s2">&quot;Interjection&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ARAM&quot;</span><span class="p">:</span>  <span class="s2">&quot;Aramaic&quot;</span><span class="p">,</span>
        <span class="s2">&quot;HEB&quot;</span><span class="p">:</span>   <span class="s2">&quot;Hebrew&quot;</span><span class="p">,</span>
        <span class="s2">&quot;PUNCT&quot;</span><span class="p">:</span> <span class="s2">&quot;Punctuation&quot;</span>
    <span class="p">}</span>

    <span class="c1"># List with pronominal parts of speech (without poss. pron. S- and refl. pron. F-)</span>
    <span class="n">pronList</span> <span class="o">=</span> <span class="p">{</span>
                 <span class="c1"># Pronouns referring to people or things</span>
        <span class="s2">&quot;P-&quot;</span><span class="p">,</span>    <span class="c1"># personal pronoun</span>
        <span class="s2">&quot;R-&quot;</span><span class="p">,</span>    <span class="c1"># relative pronoun</span>
        <span class="s2">&quot;C-&quot;</span><span class="p">,</span>    <span class="c1"># reciprocal pronoun</span>
        <span class="s2">&quot;D-&quot;</span><span class="p">,</span>    <span class="c1"># demonstrative pronoun</span>
                 <span class="c1"># Pronouns used in specific contexts</span>
        <span class="s2">&quot;K-&quot;</span><span class="p">,</span>    <span class="c1"># correlative pronoun</span>
        <span class="s2">&quot;I-&quot;</span><span class="p">,</span>    <span class="c1"># interrogative pronoun</span>
        <span class="s2">&quot;X-&quot;</span><span class="p">,</span>    <span class="c1"># indefinite pronoun</span>
        <span class="s2">&quot;Q-&quot;</span><span class="p">,</span>    <span class="c1"># correlative or interrogative pronoun</span>
                 <span class="c1"># Pronouns indicating reflexivity</span>
    <span class="p">}</span>

    <span class="c1"># List with all indeclinable parts of speech</span>
    <span class="n">indeclList</span><span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;ADV&quot;</span><span class="p">,</span>   <span class="c1"># adverb</span>
        <span class="s2">&quot;CONJ&quot;</span><span class="p">,</span>  <span class="c1"># conjunction</span>
        <span class="s2">&quot;COND&quot;</span><span class="p">,</span>  <span class="c1"># cond</span>
        <span class="s2">&quot;PRT&quot;</span><span class="p">,</span>   <span class="c1"># particle</span>
        <span class="s2">&quot;PREP&quot;</span><span class="p">,</span>  <span class="c1"># preposition</span>
        <span class="s2">&quot;INJ&quot;</span><span class="p">,</span>   <span class="c1"># interjection</span>
        <span class="s2">&quot;ARAM&quot;</span><span class="p">,</span>  <span class="c1"># aramaic</span>
        <span class="s2">&quot;HEB&quot;</span><span class="p">,</span>   <span class="c1"># hebrew</span>
        <span class="s2">&quot;N-PRI&quot;</span><span class="p">,</span> <span class="c1"># proper noun indeclinable</span>
        <span class="s2">&quot;A-NUI&quot;</span><span class="p">,</span> <span class="c1"># numeral indeclinable</span>
        <span class="s2">&quot;N-LI&quot;</span><span class="p">,</span>  <span class="c1"># letter indeclinable</span>
        <span class="s2">&quot;N-OI&quot;</span><span class="p">,</span>  <span class="c1"># noun other type indeclinable</span>
    <span class="p">}</span>
    
    <span class="c1"># grammatical case mapping</span>
    <span class="n">caseMap</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;V&quot;</span><span class="p">:</span> <span class="s2">&quot;Vocative&quot;</span><span class="p">,</span>
        <span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;Nominative&quot;</span><span class="p">,</span>
        <span class="s2">&quot;G&quot;</span><span class="p">:</span> <span class="s2">&quot;Genitive&quot;</span><span class="p">,</span>
        <span class="s2">&quot;D&quot;</span><span class="p">:</span> <span class="s2">&quot;Dative&quot;</span><span class="p">,</span>
        <span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="s2">&quot;Accusative&quot;</span>
    <span class="p">}</span>
    
    <span class="c1"># grammatical number mapping</span>
    <span class="n">numberMap</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;S&quot;</span><span class="p">:</span> <span class="s2">&quot;Singular&quot;</span><span class="p">,</span>
        <span class="s2">&quot;P&quot;</span><span class="p">:</span> <span class="s2">&quot;Plural&quot;</span><span class="p">,</span>
        <span class="s2">&quot;D&quot;</span><span class="p">:</span> <span class="s2">&quot;Dual&quot;</span>
    <span class="p">}</span>
    
    <span class="c1"># grammatical gender mapping</span>
    <span class="n">genderMap</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;M&quot;</span><span class="p">:</span> <span class="s2">&quot;Masculine&quot;</span><span class="p">,</span>
        <span class="s2">&quot;F&quot;</span><span class="p">:</span> <span class="s2">&quot;Feminine&quot;</span><span class="p">,</span>
        <span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;Neuter&quot;</span>
    <span class="p">}</span>
    
    <span class="c1"># verb tense mapping</span>
    <span class="n">tenseMap</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;P&quot;</span><span class="p">:</span>  <span class="s2">&quot;Present&quot;</span><span class="p">,</span>
        <span class="s2">&quot;I&quot;</span><span class="p">:</span>  <span class="s2">&quot;Imperfect&quot;</span><span class="p">,</span>
        <span class="s2">&quot;F&quot;</span><span class="p">:</span>  <span class="s2">&quot;Future&quot;</span><span class="p">,</span>
        <span class="s2">&quot;2F&quot;</span><span class="p">:</span> <span class="s2">&quot;Second Future&quot;</span><span class="p">,</span>
        <span class="s2">&quot;A&quot;</span><span class="p">:</span>  <span class="s2">&quot;Aorist&quot;</span><span class="p">,</span>
        <span class="s2">&quot;2A&quot;</span><span class="p">:</span> <span class="s2">&quot;Second Aorist&quot;</span><span class="p">,</span>
        <span class="s2">&quot;R&quot;</span><span class="p">:</span>  <span class="s2">&quot;Perfect&quot;</span><span class="p">,</span>
        <span class="s2">&quot;2R&quot;</span><span class="p">:</span> <span class="s2">&quot;Second Perfect&quot;</span><span class="p">,</span>
        <span class="s2">&quot;L&quot;</span><span class="p">:</span>  <span class="s2">&quot;Pluperfect&quot;</span><span class="p">,</span>
        <span class="s2">&quot;2L&quot;</span><span class="p">:</span> <span class="s2">&quot;Second Pluperfect&quot;</span><span class="p">,</span>
        <span class="s2">&quot;X&quot;</span><span class="p">:</span>  <span class="s2">&quot;No Tense Stated&quot;</span>
    <span class="p">}</span>
    
    <span class="c1"># verb voice mapping</span>
    <span class="n">voiceMap</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="s2">&quot;Active&quot;</span><span class="p">,</span>
        <span class="s2">&quot;M&quot;</span><span class="p">:</span> <span class="s2">&quot;Middle&quot;</span><span class="p">,</span>
        <span class="s2">&quot;P&quot;</span><span class="p">:</span> <span class="s2">&quot;Passive&quot;</span><span class="p">,</span>
        <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="s2">&quot;Middle or Passive&quot;</span><span class="p">,</span>
        <span class="s2">&quot;D&quot;</span><span class="p">:</span> <span class="s2">&quot;Middle Deponent&quot;</span><span class="p">,</span>
        <span class="s2">&quot;O&quot;</span><span class="p">:</span> <span class="s2">&quot;Passive Deponent&quot;</span><span class="p">,</span>
        <span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;Middle or Passive Deponent&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Q&quot;</span><span class="p">:</span> <span class="s2">&quot;Impersonal Active&quot;</span><span class="p">,</span>
        <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="s2">&quot;No Voice&quot;</span>
    <span class="p">}</span>
    
    <span class="c1"># verb mode mapping</span>
    <span class="n">moodMap</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;I&quot;</span><span class="p">:</span> <span class="s2">&quot;Indicative&quot;</span><span class="p">,</span>
        <span class="s2">&quot;S&quot;</span><span class="p">:</span> <span class="s2">&quot;Subjunctive&quot;</span><span class="p">,</span>
        <span class="s2">&quot;O&quot;</span><span class="p">:</span> <span class="s2">&quot;Optative&quot;</span><span class="p">,</span>
        <span class="s2">&quot;M&quot;</span><span class="p">:</span> <span class="s2">&quot;Imperative&quot;</span><span class="p">,</span>
        <span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;Infinitive&quot;</span><span class="p">,</span>
        <span class="s2">&quot;P&quot;</span><span class="p">:</span> <span class="s2">&quot;Participle&quot;</span><span class="p">,</span>
        <span class="s2">&quot;R&quot;</span><span class="p">:</span> <span class="s2">&quot;Imperative Participle&quot;</span>
    <span class="p">}</span>
    
    <span class="c1"># grammatical person mapping</span>
    <span class="n">personMap</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;1&quot;</span><span class="p">:</span> <span class="s2">&quot;First Person&quot;</span><span class="p">,</span>
        <span class="s2">&quot;2&quot;</span><span class="p">:</span> <span class="s2">&quot;Second Person&quot;</span><span class="p">,</span>
        <span class="s2">&quot;3&quot;</span><span class="p">:</span> <span class="s2">&quot;Third Person&quot;</span>
    <span class="p">}</span>
    
    <span class="c1"># Extra verb info mapping</span>
    <span class="n">verbExtraMap</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;-M&quot;</span><span class="p">:</span>   <span class="s2">&quot;Middle significance&quot;</span><span class="p">,</span>
        <span class="s2">&quot;-C&quot;</span><span class="p">:</span>   <span class="s2">&quot;Contracted form&quot;</span><span class="p">,</span>
        <span class="s2">&quot;-T&quot;</span><span class="p">:</span>   <span class="s2">&quot;Transitive&quot;</span><span class="p">,</span>
        <span class="s2">&quot;-A&quot;</span><span class="p">:</span>   <span class="s2">&quot;Aeolic&quot;</span><span class="p">,</span>
        <span class="s2">&quot;-ATT&quot;</span><span class="p">:</span> <span class="s2">&quot;Attic&quot;</span><span class="p">,</span>
        <span class="s2">&quot;-AP&quot;</span><span class="p">:</span>  <span class="s2">&quot;Apocopated form&quot;</span><span class="p">,</span>
        <span class="s2">&quot;-IRR&quot;</span><span class="p">:</span> <span class="s2">&quot;Irregular or impure form&quot;</span>
    <span class="p">}</span>
    
    <span class="c1"># suffix mapping</span>
    <span class="n">suffixMap</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;-K&quot;</span><span class="p">:</span>   <span class="s2">&quot;Crasis&quot;</span><span class="p">,</span>
        <span class="s2">&quot;-N&quot;</span><span class="p">:</span>   <span class="s2">&quot;Negative&quot;</span><span class="p">,</span>
        <span class="s2">&quot;-S&quot;</span><span class="p">:</span>   <span class="s2">&quot;Superlative&quot;</span><span class="p">,</span>
        <span class="s2">&quot;-C&quot;</span><span class="p">:</span>   <span class="s2">&quot;Comparative&quot;</span><span class="p">,</span>
        <span class="s2">&quot;-ABB&quot;</span><span class="p">:</span> <span class="s2">&quot;Abbreviated&quot;</span><span class="p">,</span>
        <span class="s2">&quot;-I&quot;</span><span class="p">:</span>   <span class="s2">&quot;Interrogative&quot;</span><span class="p">,</span>
        <span class="s2">&quot;-ATT&quot;</span><span class="p">:</span> <span class="s2">&quot;Attic&quot;</span><span class="p">,</span>
        <span class="s2">&quot;-P&quot;</span><span class="p">:</span>   <span class="s2">&quot;Particle Attached&quot;</span>
    <span class="p">}</span>

    <span class="c1"># Prepare output dict</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Type-check</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tag_input</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Part of Speech&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Unknown or Unsupported&quot;</span>
        <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Error&quot;</span><span class="p">]</span><span class="o">=</span><span class="s2">&quot;Input must be a string&quot;</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[decode_tag] ERROR: Expected str, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">tag_input</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">!r}</span><span class="s2">: </span><span class="si">{</span><span class="n">tag_input</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="c1"># Emptiness check</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">tag_input</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
        <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Part of Speech&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Unknown or Unsupported&quot;</span>
        <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Error&quot;</span><span class="p">]</span><span class="o">=</span> <span class="s2">&quot;Input cannot be empty&quot;</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[decode_tag] ERROR: Input is empty or only whitespace: </span><span class="si">{</span><span class="n">tag_input</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="c1"># Normalize and upper-case once, keep original for suffix lookup</span>
    <span class="n">full_tag</span> <span class="o">=</span> <span class="n">tag_input</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

    
    <span class="c1"># Decode part of speech</span>
    <span class="c1"># The first line retrieve an array of all the keys from posMap.</span>
    <span class="c1"># We will iterating and find the first matching key.</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">posMap</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">tag_input</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">key</span>
            <span class="k">break</span>
    
    <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Part of Speech&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Unknown or Unsupported&quot;</span>
        <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Error&quot;</span><span class="p">]</span><span class="o">=</span><span class="s2">&quot;POS unknown&quot;</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[decode_tag] ERROR: POS unknown (</span><span class="si">{</span><span class="n">tag_input</span><span class="si">!r}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Part of Speech&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">posMap</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
    <span class="c1"># strip off the POS prefix for feature decoding</span>
    <span class="n">input_str</span> <span class="o">=</span> <span class="n">full_tag</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">):]</span>
    
    <span class="c1"># Further decoding based on the detected part of speech</span>


<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Verb patterns are depending on the &#39;mood&#39;:</span>

<span class="sd">       V- tense voice I person number      [- verb-extra]</span>
<span class="sd">       V- tense voice S person number      [- verb-extra]</span>
<span class="sd">       V- tense voice O person number      [- verb-extra]</span>
<span class="sd">       V- tense voice M person number      [- verb-extra]</span>
<span class="sd">       # The next [- verb-extra] was added to decode tag V-RAN-ATT (Luke 24:23)</span>
<span class="sd">       V- tense voice N                    [- verb-extra]   </span>
<span class="sd">       V- tense voice P case number gender [- verb-extra]</span>
<span class="sd">       V- tense voice R case number gender [- verb-extra]</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="s2">&quot;V-&quot;</span><span class="p">:</span>

        <span class="c1"># Regex to split into the three parts: TVM, features, extra</span>
        <span class="n">_PATTERN</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            ^V</span>
<span class="s2">            -(?P&lt;tvm&gt;[0-9]?[A-Z]</span><span class="si">{3}</span><span class="s2">)     # optional digit + 3 letters -&gt; tense/voice/mood e.g. &quot;PAI&quot; or &quot;2A...&quot;</span>
<span class="s2">            (?:-(?P&lt;feat&gt;[1-3A-Z]{2,3}))?  # person/number or case/number/gender</span>
<span class="s2">            (?:-(?P&lt;extra&gt;[A-Z-]+))?       # optional verb-extra like &quot;ATT&quot;</span>
<span class="s2">            $</span>
<span class="s2">            &quot;&quot;&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">_PATTERN</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">tag_input</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="p">:</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Error&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Tag </span><span class="si">{</span><span class="n">tag_input</span><span class="si">}</span><span class="s2"> does not match expected pattern.&quot;</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[decode_tag] Regex to split verb parts failed for </span><span class="si">{</span><span class="n">tag_input</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">output</span>

        <span class="n">groups</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span>
        <span class="n">tvm</span>   <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="s2">&quot;tvm&quot;</span><span class="p">]</span>    <span class="ow">or</span> <span class="s2">&quot;&quot;</span>
        <span class="n">feat</span>  <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="s2">&quot;feat&quot;</span><span class="p">]</span>   <span class="ow">or</span> <span class="s2">&quot;&quot;</span>
        <span class="n">extra</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="s2">&quot;extra&quot;</span><span class="p">]</span>  <span class="ow">or</span> <span class="s2">&quot;&quot;</span>


        <span class="c1"># parse Tense–Voice–Mood from &#39;tvm&#39;</span>
        <span class="c1"># Length of this part should be either 3 or 4 </span>
        <span class="n">tenseKey</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">tk</span> <span class="k">for</span> <span class="n">tk</span> <span class="ow">in</span> <span class="n">tenseMap</span> <span class="k">if</span> <span class="n">tvm</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">tk</span><span class="p">)),</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tenseKey</span><span class="p">:</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Tense&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tenseMap</span><span class="p">[</span><span class="n">tenseKey</span><span class="p">]</span>
            <span class="n">rem</span> <span class="o">=</span> <span class="n">tvm</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">tenseKey</span><span class="p">):]</span>
            <span class="c1"># length should of `rem` is now 2</span>
            <span class="n">voiceKey</span><span class="o">=</span><span class="n">rem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">moodKey</span><span class="o">=</span><span class="n">rem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Voice&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">voiceMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">voiceKey</span><span class="p">,</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Mood&quot;</span><span class="p">]</span>  <span class="o">=</span> <span class="n">moodMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">moodKey</span><span class="p">,</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Tense&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Unknown&quot;</span> <span class="c1"># </span>

        <span class="c1"># parse Person/Number or Case/Number/Gender from &#39;feat&#39; based on &#39;mood&#39;</span>

        <span class="c1"># moods Present/imperfect → Case/Number/Gender</span>
        <span class="k">if</span> <span class="n">moodKey</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;P&#39;</span><span class="p">,</span><span class="s1">&#39;R&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">feat</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Case&quot;</span><span class="p">]</span>   <span class="o">=</span> <span class="n">caseMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">feat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>
                <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Number&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numberMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">feat</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>
                <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Gender&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">genderMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">feat</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Error&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Incomplete feature code&quot;</span>
                <span class="k">if</span> <span class="n">debug</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[decode_tag] ERROR: Incorrect feature code (‘</span><span class="si">{</span><span class="n">feat</span><span class="si">}</span><span class="s2">’) for mood </span><span class="si">{</span><span class="n">moodKey</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">mood</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="c1"># Indicative/Subjunctive/Optative/Imperative → Person/Number</span>
        <span class="k">elif</span> <span class="n">moodKey</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;S&#39;</span><span class="p">,</span><span class="s1">&#39;O&#39;</span><span class="p">,</span><span class="s1">&#39;M&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">feat</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Person&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">personMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">feat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>
                <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Number&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numberMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">feat</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Error&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Incorrect feature code&quot;</span>
                <span class="k">if</span> <span class="n">debug</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[decode_tag] ERROR: Incorrect feature code (‘</span><span class="si">{</span><span class="n">feat</span><span class="si">}</span><span class="s2">’) for mood </span><span class="si">{</span><span class="n">moodKey</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">mood</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="c1"># Infinitive -&gt; according to definition, there should be no more info. </span>
        <span class="c1"># However, in practice it may also contain a suffix/verb extra element (e.g. V-RAN-ATT at Luke 24:23)</span>
        <span class="k">elif</span> <span class="n">moodKey</span><span class="o">==</span><span class="s1">&#39;N&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">feat</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Warning&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Unexpected extra element (‘</span><span class="si">{</span><span class="n">feat</span><span class="si">}</span><span class="s2">’) for mood N will be handled as verb extra&quot;</span>
                <span class="n">extra</span><span class="o">=</span><span class="n">feat</span>

        <span class="c1"># If the moodKey is not handled by any of the above, it contains incorrect information</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Error&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Unrecognized moodKey </span><span class="si">{</span><span class="n">moodKey</span><span class="si">!r}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[decode_tag] ERROR: Unrecognized moodKey </span><span class="si">{</span><span class="n">moodKey</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Optional verb-extra</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">extra</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">raw_suffix</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="n">extra</span>
            <span class="k">if</span> <span class="n">raw_suffix</span> <span class="ow">in</span> <span class="n">verbExtraMap</span><span class="p">:</span>
                <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Verb extra&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">verbExtraMap</span><span class="p">[</span><span class="n">raw_suffix</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Verb extra&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Unknown verb extra&quot;</span>
                <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Warning&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Unknown verb extra </span><span class="si">{</span><span class="n">raw_suffix</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[decode_tag] WARNING: Unknown verb extra (</span><span class="si">{</span><span class="n">input_str</span><span class="si">!r}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="c1"># we are done for verbs </span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="c1"># indeclinables</span>
    <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">indeclList</span><span class="p">:</span>
        <span class="c1"># This follows pattern: pos [suffix]</span>
        <span class="c1"># Only proceed if there actually is a dash in the original tag</span>
        <span class="k">if</span> <span class="s2">&quot;-&quot;</span> <span class="ow">in</span> <span class="n">input_str</span><span class="p">:</span>
            <span class="c1"># If it’s a known suffix, map it</span>
            <span class="k">if</span> <span class="n">input_str</span> <span class="ow">in</span> <span class="n">suffixMap</span><span class="p">:</span>
                <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Suffix&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">suffixMap</span><span class="p">[</span><span class="n">input_str</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Warning&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Unknown suffix&quot;</span>
                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[decode_tag] WARNING: Unknown suffix (</span><span class="si">{</span><span class="n">tag_input</span><span class="si">!r}</span><span class="s2">)&quot;</span><span class="p">)</span>
                
        <span class="c1"># no dash → no suffix (which is perfectly OK)</span>

        <span class="c1"># we are done for indeclinables </span>
        <span class="k">return</span> <span class="n">output</span>
    <span class="c1"># </span>
    <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;N-&quot;</span><span class="p">,</span> <span class="s2">&quot;A-&quot;</span><span class="p">,</span> <span class="s2">&quot;T-&quot;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_str</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Case&quot;</span><span class="p">]</span>   <span class="o">=</span> <span class="n">caseMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">input_str</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Number&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numberMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">input_str</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Gender&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">genderMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">input_str</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Warning&quot;</span><span class="p">]</span><span class="o">=</span> <span class="s2">&quot;Not enough elements provided&quot;</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[decode_tag] WARNING: Not enough elements provided for indeclinable (</span><span class="si">{</span><span class="n">tag_input</span><span class="si">!r}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="c1"># note: suffix will be decoded in the default branch</span>

    <span class="c1"># Reflexive Pronoun</span>
    <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;F-&quot;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_str</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Person&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">personMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">input_str</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Case&quot;</span><span class="p">]</span>   <span class="o">=</span> <span class="n">caseMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">input_str</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Number&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numberMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">input_str</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Gender&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">genderMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">input_str</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Warning&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Not enough elements provided&quot;</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[decode_tag] WARNING: Not enough elements provided for reflexive pronoun (</span><span class="si">{</span><span class="n">tag_input</span><span class="si">!r}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="c1"># note: suffix will be decoded in the default branch</span>

    <span class="c1"># Possessive Pronoun</span>
    <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;S-&quot;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_str</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Person of Possessor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">personMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">input_str</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Number of Possessor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numberMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">input_str</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Case of Possessed&quot;</span><span class="p">]</span>   <span class="o">=</span> <span class="n">caseMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">input_str</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Number of Possessed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numberMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">input_str</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Gender of Possessed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">genderMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">input_str</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Warning&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Not enough elements provided&quot;</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[decode_tag] WARNING: Not enough elements provided for possesive pronoun (</span><span class="si">{</span><span class="n">tag_input</span><span class="si">!r}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="c1"># note: suffix will be decoded in the default branch</span>
    
    <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">pronList</span><span class="p">:</span>
        <span class="c1"># The overall pattern is: pos [person] case number [gender] [suffix]</span>
        <span class="c1"># Pattern 1: [case,number]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_str</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Case&quot;</span><span class="p">]</span>   <span class="o">=</span> <span class="n">caseMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">input_str</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Number&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numberMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">input_str</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>

        <span class="c1"># Pattern 2: [person, case, number]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_str</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^[123]$&#39;</span><span class="p">,</span> <span class="n">input_str</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Person&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">personMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">input_str</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Case&quot;</span><span class="p">]</span>   <span class="o">=</span> <span class="n">caseMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">input_str</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Number&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numberMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">input_str</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>
    
        <span class="c1"># Pattern 3: [case, number, gender]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_str</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Case&quot;</span><span class="p">]</span>   <span class="o">=</span> <span class="n">caseMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">input_str</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Number&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numberMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">input_str</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Gender&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">genderMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">input_str</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">)</span>
    
        <span class="c1"># Pronoun-specific suffix (e.g. the “-K” in “P-1AS-K”)</span>
        <span class="k">if</span> <span class="s2">&quot;-&quot;</span> <span class="ow">in</span> <span class="n">input_str</span><span class="p">:</span>
            <span class="n">raw_suffix</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="n">input_str</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">raw_suffix</span> <span class="ow">in</span> <span class="n">suffixMap</span><span class="p">:</span>
                <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Suffix&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">suffixMap</span><span class="p">[</span><span class="n">raw_suffix</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Warning&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Unknown suffix&quot;</span>
                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[decode_tag] WARNING: Unknown suffix for pronoun </span><span class="si">{</span><span class="n">raw_suffix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># we are done for indeclinables </span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="c1"># Only proceed if there actually is a dash after the POS tag</span>
    <span class="k">if</span> <span class="s2">&quot;-&quot;</span> <span class="ow">in</span> <span class="n">input_str</span><span class="p">:</span>
        <span class="c1"># Grab everything after the last &#39;-&#39; (including the dash)</span>
        <span class="n">raw_suffix</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span><span class="o">+</span><span class="n">input_str</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># If it’s a known suffix, map it</span>
        <span class="k">if</span> <span class="n">raw_suffix</span> <span class="ow">in</span> <span class="n">suffixMap</span><span class="p">:</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Suffix&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">suffixMap</span><span class="p">[</span><span class="n">raw_suffix</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span><span class="p">[</span><span class="s2">&quot;Warning&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Unknown suffix&quot;</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[decode_tag] ERROR: Unknown suffix in default branch </span><span class="si">{</span><span class="n">raw_suffix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># no dash → no suffix (which is perfectly OK)</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[decode_tag] Return (</span><span class="si">{</span><span class="n">output</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">output</span></div>


    <span class="c1"># End of function decode_tag()</span>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Tony Jurg.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>